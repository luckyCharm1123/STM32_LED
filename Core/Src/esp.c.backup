/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : esp.c
  * @brief          : ESP-01S WiFi模块驱动程序
  * @details        : 本文件提供ESP-01S模块的初始化、AT指令通信、WiFi连接、
  *                  TCP/IP通信等功能。通过USART2(PA2/PA3)与ESP-01S通信。
  * @author         : STM32 Developer
  * @version        : V1.0
  * @date           : 2025-12-22
  *
  * @par 硬件连接
  * STM32F103C8T6    <-->    ESP-01S
  * PA2 (USART2_TX)  <-->    RX
  * PA3 (USART2_RX)  <-->    TX
  * 3.3V             <-->    VCC
  * GND              <-->    GND
  * GPIO0            <-->    GPIO0 (悬空或接高电平)
  * GPIO2            <-->    GPIO2 (悬空或接高电平)
  * RST              <-->    RST (可选，接高电平)
  * CH_PD            <-->    CH_PD (接高电平使能)
  *
  * @note ESP-01S默认波特率：115200
  * @note 工作电压：3.3V（注意：不能接5V，否则会损坏）
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "esp.h"
#include "main.h"
#include <string.h>
#include <stdio.h>

/* 外部变量声明 */
extern UART_HandleTypeDef huart1;  // USART1句柄（调试用）
extern UART_HandleTypeDef huart2;  // USART2句柄（ESP通信用）
extern void DEBUG_SendString(const char *str);   // 调试串口发送函数
extern void USART2_SendString(const char *str);  // 串口发送函数
extern uint8_t rx_buffer[128];  // 主串口接收缓冲区

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define ESP_RX_BUFFER_SIZE 512  // ESP接收缓冲区大小
#define ESP_TX_BUFFER_SIZE 256  // ESP发送缓冲区大小
#define ESP_TIMEOUT_MS 5000     // ESP指令超时时间（毫秒）
#define ESP_CMD_DELAY_MS 100    // 指令间延时（毫秒）

/* ESP AT指令定义 */
#define AT_CMD_OK          "OK"
#define AT_CMD_ERROR       "ERROR"
#define AT_CMD_READY       "ready"
#define AT_CMD_WIFI_CONNECTED "WIFI CONNECTED"
#define AT_CMD_WIFI_GOT_IP "WIFI GOT IP"

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
#define ESP_DELAY(ms) HAL_Delay(ms)
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
uint8_t esp_rx_buffer[ESP_RX_BUFFER_SIZE];  // ESP接收缓冲区
uint8_t esp_tx_buffer[ESP_TX_BUFFER_SIZE];  // ESP发送缓冲区
uint16_t esp_rx_index = 0;                  // ESP接收索引
uint8_t esp_rx_complete = 0;                // ESP接收完成标志
uint8_t esp_response_ready = 0;             // ESP响应就绪标志
uint32_t esp_timeout_counter = 0;           // 超时计数器
uint32_t esp_last_rx_time = 0;              // 最后接收时间戳
volatile uint8_t esp_receiving = 0;         // 正在接收标志（防止中断中重置）

/* ESP模块状态 - 使用头文件中定义的结构体 */
ESP_Status_t esp_status = {0};  // ESP状态结构体

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */
void ESP_SendATCommand(const char *cmd, uint32_t timeout);

/**
  * @brief 检测ESP是否死锁并尝试恢复
  * @retval ESP_OK: ESP正常, ESP_ERROR: ESP死锁且无法恢复
  * @details 当ESP连续无响应时，可能进入死锁状态
  *          通过发送多个短AT命令尝试唤醒ESP
  */
static uint8_t ESP_DetectAndRecover(void)
{
  char debug_msg[128];

  DEBUG_SendString("\r\n[ESP RECOVERY] Attempting to recover ESP module...\r\n");

  /* 清空接收缓冲区 */
  esp_rx_index = 0;
  esp_rx_complete = 0;
  esp_response_ready = 0;
  memset(esp_rx_buffer, 0, ESP_RX_BUFFER_SIZE);

  /* 策略: 连续发送AT命令尝试唤醒ESP */
  uint8_t attempt;
  for(attempt = 0; attempt < 5; attempt++)
  {
    snprintf(debug_msg, sizeof(debug_msg), "Recovery attempt %d/5...\r\n", attempt + 1);
    DEBUG_SendString(debug_msg);

    /* 发送AT命令 - 直接使用HAL_UART_Transmit避免ESP_SendATCommand的额外延迟 */
    HAL_UART_Transmit(&huart2, (uint8_t*)"AT\r\n", 4, 100);

    /* 等待响应 */
    uint32_t wait_start = HAL_GetTick();
    uint8_t got_response = 0;

    while(HAL_GetTick() - wait_start < 1000)
    {
      if(esp_response_ready)
      {
        got_response = 1;

        /* 立即保存响应 */
        char local_buffer[ESP_RX_BUFFER_SIZE];
        strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
        local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

        esp_response_ready = 0;
        esp_rx_index = 0;

        if(strstr(local_buffer, "OK") != NULL)
        {
          DEBUG_SendString("[ESP RECOVERY] Successfully recovered ESP module!\r\n");
          ESP_DELAY(500);
          return ESP_OK;
        }
        break;
      }
      ESP_DELAY(10);
    }

    /* 如果没有响应，等待更长时间再重试 */
    if(!got_response)
    {
      ESP_DELAY(500);  /* 等待500ms */
    }
  }

  /* 所有恢复尝试都失败 */
  DEBUG_SendString("[ESP RECOVERY] Failed - ESP module appears to be deadlocked\r\n");
  DEBUG_SendString("[ESP RECOVERY] Recommendation: Power cycle the ESP module\r\n");
  return ESP_ERROR;
}
/* USER CODE END PFP */
uint8_t ESP_WaitForResponse(const char *expected, uint32_t timeout);
void ESP_ProcessResponse(void);
void ESP_ParseIP(void);
void ESP_ParseMAC(void);  // 声明MAC地址解析函数
/* USER CODE END PFP */

/* External functions --------------------------------------------------------*/
/* USER CODE BEGIN EF */

/* USER CODE END EF */

/* Private functions ---------------------------------------------------------*/
/* USER CODE BEGIN PF */

/**
  * @brief ESP-01S模块初始化
  * @param None
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 执行完整的ESP模块初始化流程：
  *          1. 发送AT指令测试模块是否在线
  *          2. 关闭回显（ATE0）
  *          3. 设置为Station模式
  *          4. 等待模块就绪
  */
uint8_t ESP_Init(void)
{
  uint8_t retry = 0;
  
  ESP_DELAY(1000);  // 等待模块上电稳定
  
  /* 步骤1: 测试模块是否响应 */
  for(retry = 0; retry < 3; retry++)
  {
    ESP_SendATCommand("AT\r\n", 1000);
    if(ESP_WaitForResponse("OK", 1000))
    {
      break;
    }
    ESP_DELAY(500);
  }
  
  if(retry >= 3)
  {
    return ESP_ERROR;  // 模块无响应
  }
  
  /* 步骤2: 关闭回显 */
  ESP_SendATCommand("ATE0\r\n", 1000);
  if(!ESP_WaitForResponse("OK", 1000))
  {
    return ESP_ERROR;
  }
  
  /* 步骤3: 设置为Station模式 */
  ESP_SendATCommand("AT+CWMODE=1\r\n", 1000);
  if(!ESP_WaitForResponse("OK", 1000))
  {
    return ESP_ERROR;
  }
  
  /* 步骤4: 获取模块信息 */
  ESP_SendATCommand("AT+GMR\r\n", 1000);
  ESP_WaitForResponse("OK", 1000);
  
  /* 步骤5: 获取MAC地址 */
  ESP_SendATCommand("AT+CIPSTAMAC?\r\n", 1000);
  if(ESP_WaitForResponse("OK", 1000))
  {
    ESP_ParseMAC();
  }
  
  esp_status.initialized = 1;
  return ESP_OK;
}

/**
  * @brief 检查WiFi自动连接状态
  * @param None
  * @retval ESP_OK: 已连接, ESP_ERROR: 未连接
  * @details 通电后检查ESP是否自动连接到WiFi，
  *          如果未连接，会尝试设置为Station模式
  */
uint8_t ESP_CheckAutoConnect(void)
{
  uint8_t retry = 0;

  DEBUG_SendString("\r\n=== ESP Auto-Connect Check ===\r\n");

  /* 增加初始等待时间 - ESP-01S需要2-3秒启动 */
  DEBUG_SendString("Waiting for ESP module to initialize...\r\n");
  ESP_DELAY(2000);  /* 从1秒增加到2秒 */

  /* 步骤1: 测试模块是否响应并关闭回显 - 带重试机制 */
  uint8_t first_response = 0;
  uint8_t attempt;

  /* 最多尝试3次AT命令，每次超时后等待更长时间 */
  for(attempt = 0; attempt < 3; attempt++)
  {
    if(attempt > 0)
    {
      char retry_msg[64];
      snprintf(retry_msg, sizeof(retry_msg), "Retry %d/3...\r\n", attempt);
      DEBUG_SendString(retry_msg);

      /* 重试前等待更长时间，让ESP有更多启动时间 */
      ESP_DELAY(1500);
    }

    DEBUG_SendString("Step 1: Testing ESP response...\r\n");
    ESP_SendATCommand("AT\r\n", 1000);

    /* 等待响应 - 每次尝试的超时时间递增 */
    uint32_t timeout = 3000 + (attempt * 2000);  /* 3秒, 5秒, 7秒 */
    uint32_t first_wait = HAL_GetTick();

    while(HAL_GetTick() - first_wait < timeout)
    {
      if(esp_response_ready)
      {
        first_response = 1;

        /* 立即保存响应到本地缓冲区 */
        char local_buffer[ESP_RX_BUFFER_SIZE];
        strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
        local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

        /* 立即重置标志 */
        esp_response_ready = 0;
        esp_rx_index = 0;

        char debug_msg[ESP_RX_BUFFER_SIZE + 32];
        int esp_len = strlen(local_buffer);
        if(esp_len > 100) {
          snprintf(debug_msg, sizeof(debug_msg), "  [ESP] %.100s...\r\n", local_buffer);
        } else {
          snprintf(debug_msg, sizeof(debug_msg), "  [ESP] %s\r\n", local_buffer);
        }
        DEBUG_SendString(debug_msg);

        if(strstr(local_buffer, "OK") != NULL)
        {
          DEBUG_SendString("[OK] ESP module is responding!\r\n");
          break;
        }
      }
      ESP_DELAY(10);
    }

    if(first_response)
    {
      break;  /* 成功收到响应，退出重试循环 */
    }
  }

  if(!first_response)
  {
    DEBUG_SendString("[ERROR] No response from ESP module after 3 attempts\r\n");

    /* 尝试恢复ESP模块 */
    if(ESP_DetectAndRecover() == ESP_OK)
    {
      /* 恢复成功，继续执行 */
      DEBUG_SendString("[RECOVERED] ESP module is now responding, continuing...\r\n");
      first_response = 1;  /* 标记为已响应 */
    }
    else
    {
      /* 恢复失败，显示详细错误信息 */
      DEBUG_SendString("  Troubleshooting:\r\n");
      DEBUG_SendString("  1. Check power supply (3.3V, 500mA minimum)\r\n");
      DEBUG_SendString("  2. Verify TX/RX connections (not reversed)\r\n");
      DEBUG_SendString("  3. Ensure GND is connected\r\n");
      DEBUG_SendString("  4. Wait 3 seconds after power-on\r\n");
      DEBUG_SendString("  5. Check if GPIO0 is floating (not grounded)\r\n");
      DEBUG_SendString("  6. Try power cycling the ESP module\r\n");
      return ESP_ERROR;
    }
  }
  
  /* 尝试关闭回显 */
  DEBUG_SendString("Step 1b: Disabling echo...\r\n");
  for(retry = 0; retry < 3; retry++)
  {
    ESP_SendATCommand("ATE0\r\n", 1000);
    if(ESP_WaitForResponse("OK", 1000))
    {
      DEBUG_SendString("[OK] Echo disabled successfully\r\n");
      break;
    }
    ESP_DELAY(500);
  }
  
  if(retry >= 3)
  {
    /* 回显关闭失败，继续尝试普通AT命令 */
    DEBUG_SendString("[WARNING] Could not disable echo, continuing...\r\n");
    for(retry = 0; retry < 3; retry++)
    {
      ESP_SendATCommand("AT\r\n", 1000);
      if(ESP_WaitForResponse("OK", 1000))
      {
        break;
      }
      ESP_DELAY(500);
    }
    
    if(retry >= 3)
    {
      /* 尝试重启ESP模块 */
      DEBUG_SendString("ESP not responding, attempting restart...\r\n");
      ESP_SendATCommand("AT+RST\r\n", 1000);
      ESP_DELAY(3000);  // 等待重启完成
      
      /* 重启后再次尝试 */
      for(retry = 0; retry < 3; retry++)
      {
        ESP_SendATCommand("ATE0\r\n", 1000);
        if(ESP_WaitForResponse("OK", 1000))
        {
          break;
        }
        ESP_DELAY(500);
      }
      
      if(retry >= 3)
      {
        return ESP_ERROR;  // 模块无响应
      }
    }
  }
  
  /* 步骤2: 检查WiFi连接状态 - 使用AT+CIPSTATUS指令 */
  ESP_SendATCommand("AT+CIPSTATUS\r\n", 1000);

  /* 等待响应 - AT+CIPSTATUS返回连接状态信息 */
  uint32_t start_time = HAL_GetTick();
  uint8_t wifi_connected = 0;
  uint8_t got_status = 0;

  while(HAL_GetTick() - start_time < 3000)
  {
    if(esp_response_ready)
    {
      /* 立即保存响应到本地缓冲区，避免被新数据覆盖 */
      char local_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志和索引，允许接收新数据 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 检查连接状态 */
      if(strstr(local_buffer, "STATUS:2") != NULL ||
         strstr(local_buffer, "STATUS:3") != NULL)
      {
        wifi_connected = 1;
        got_status = 1;
      }
      else if(strstr(local_buffer, "STATUS:5") != NULL)
      {
        wifi_connected = 0;
        got_status = 1;
      }

      /* 检查是否收到OK（表示指令完成） */
      if(strstr(local_buffer, "OK") != NULL)
      {
        /* 如果WiFi已连接，直接返回成功，跳过Step 3和Step 4 */
        if(wifi_connected && got_status)
        {
          DEBUG_SendString("=== Auto-Connect Check Complete ===\r\n\r\n");
          esp_status.connected = 1;
          return ESP_OK;  /* 直接返回，不再执行后续步骤 */
        }

        /* 如果收到了OK但没有STATUS信息，继续等待 */
        if(!got_status)
        {
          continue;
        }

        /* WiFi未连接，退出循环继续后续配置步骤 */
        break;
      }
    }
    ESP_DELAY(10);
  }
  
  /* 检查是否在循环外检测到WiFi连接（STATUS和OK分两行的情况） */
  if(wifi_connected && got_status)
  {
    DEBUG_SendString("=== Auto-Connect Check Complete ===\r\n\r\n");
    esp_status.connected = 1;
    return ESP_OK;
  }

  /* 步骤3: 如果未连接，设置为Station模式 */
  /* DEBUG_SendString("Step 3: Setting WiFi mode to Station (AT+CWMODE=1)...\r\n"); */
  ESP_SendATCommand("AT+CWMODE=1\r\n", 1000);
  if(!ESP_WaitForResponse("OK", 1000))
  {
    DEBUG_SendString("[ERROR] Failed to set WiFi mode\r\n\r\n");
    return ESP_ERROR;
  }
  /* DEBUG_SendString("[OK] WiFi mode set to Station\r\n"); */

  /* 步骤4: 再次检查WiFi状态 */
  /* DEBUG_SendString("Step 4: Re-checking WiFi status...\r\n"); */
  ESP_SendATCommand("AT+CIPSTATUS\r\n", 1000);

  /* 等待响应 - 需要等待完整的响应 */
  start_time = HAL_GetTick();
  uint8_t status_wifi_connected = 0;

  while(HAL_GetTick() - start_time < 3000)
  {
    if(esp_response_ready)
    {
      /* 立即保存响应到本地缓冲区，避免被新数据覆盖 */
      char local_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志和索引，允许接收新数据 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 检查连接状态 */
      if(strstr(local_buffer, "STATUS:2") != NULL ||
         strstr(local_buffer, "STATUS:3") != NULL)
      {
        status_wifi_connected = 1;
      }
      else if(strstr(local_buffer, "STATUS:5") != NULL)
      {
        status_wifi_connected = 0;
        DEBUG_SendString("[INFO] WiFi not connected\r\n");
      }

      /* 检查是否收到OK（表示指令完成） */
      if(strstr(local_buffer, "OK") != NULL)
      {
        /* 如果找到了WiFi连接状态，说明已连接WiFi */
        if(status_wifi_connected)
        {
          DEBUG_SendString("=== Auto-Connect Check Complete ===\r\n\r\n");
          esp_status.connected = 1;
          return ESP_OK;
        }
        else
        {
          break;
        }
      }
    }
    ESP_DELAY(10);
  }
  
  /* 未连接WiFi */
  DEBUG_SendString("[INFO] No active WiFi connection found\r\n");
  DEBUG_SendString("=== Auto-Connect Check Complete ===\r\n\r\n");
  esp_status.connected = 0;
  return ESP_ERROR;
}

/**
  * @brief 连接WiFi网络
  * @param ssid: WiFi名称
  * @param password: WiFi密码
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 使用AT+CWJAP指令连接指定的WiFi网络
  */
uint8_t ESP_ConnectWiFi(const char *ssid, const char *password)
{
  char cmd[128];
  char debug_msg[ESP_RX_BUFFER_SIZE + 32];  /* 调试信息缓冲区 */
  
  /* 构建连接指令 */
  snprintf(cmd, sizeof(cmd), "AT+CWJAP=\"%s\",\"%s\"\r\n", ssid, password);
  
  /* 发送连接指令 */
  ESP_SendATCommand(cmd, 1000);
  
  /* 等待连接结果 - WiFi连接可能需要15-30秒 */
  /* ESP可能返回多种响应：WIFI CONNECTED, WIFI GOT IP, OK, 或者 ERROR */
  uint32_t start_time = HAL_GetTick();
  uint8_t got_wifi_connected = 0;
  uint8_t got_wifi_got_ip = 0;
  uint8_t got_ok = 0;
  
  /* 最多等待30秒 */
  while(HAL_GetTick() - start_time < 30000)
  {
    if(esp_response_ready)
    {
      /* 立即保存响应到本地缓冲区，避免被新数据覆盖 */
      char local_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志和索引，允许接收新数据 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 检查是否收到WIFI CONNECTED */
      if(strstr(local_buffer, "WIFI CONNECTED") != NULL)
      {
        got_wifi_connected = 1;
        DEBUG_SendString("[Stage 1/3] WIFI CONNECTED - WiFi association successful\r\n");
      }

      /* 检查是否收到WIFI GOT IP */
      if(strstr(local_buffer, "WIFI GOT IP") != NULL ||
         strstr(local_buffer, "GOT IP") != NULL)
      {
        got_wifi_got_ip = 1;
        DEBUG_SendString("[Stage 2/3] WIFI GOT IP - DHCP IP address obtained\r\n");
      }

      /* 检查是否收到OK */
      if(strstr(local_buffer, "OK") != NULL)
      {
        got_ok = 1;
        DEBUG_SendString("[Stage 3/3] OK - Connection command completed\r\n");
      }

      /* 检查是否收到FAIL（真正的失败） */
      if(strstr(local_buffer, "FAIL") != NULL)
      {
        DEBUG_SendString("[ERROR] Connection FAILED - Check SSID/Password\r\n");
        return ESP_ERROR;
      }

      /* 如果收到ERROR但没有其他成功标志，可能是真正的错误 */
      if(strstr(local_buffer, "ERROR") != NULL)
      {
        if(!got_wifi_connected && !got_wifi_got_ip && !got_ok)
        {
          DEBUG_SendString("[ERROR] Connection error (no success indicators)\r\n");
          return ESP_ERROR;
        }
        else
        {
          DEBUG_SendString("[WARNING] Received ERROR but connection may succeed\r\n");
        }
      }

      /* 连接成功的判断条件：收到OK，并且之前收到了WIFI CONNECTED或GOT IP */
      if(got_ok && (got_wifi_connected || got_wifi_got_ip))
      {
        /* 连接成功，等待DHCP并获取IP地址 */
        DEBUG_SendString("\r\n[OK] WiFi Connected, getting IP...\r\n");

        /* 等待DHCP完成 - 简化为等待3秒 */
        ESP_DELAY(3000);

        /* 查询IP地址 - 使用AT+CIFSR */
        ESP_SendATCommand("AT+CIFSR\r\n", 2000);

        /* 等待响应 - 简化逻辑，最多等待2秒 */
        uint32_t ip_start = HAL_GetTick();
        uint8_t got_ip = 0;

        /* 先清空可能的旧响应 */
        esp_response_ready = 0;
        ESP_DELAY(200);

        while(HAL_GetTick() - ip_start < 2000)
        {
          if(esp_response_ready)
          {
            /* 立即保存响应到本地缓冲区 */
            char ip_local_buffer[ESP_RX_BUFFER_SIZE];
            strncpy(ip_local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
            ip_local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

            /* 立即重置标志和索引 */
            esp_response_ready = 0;
            esp_rx_index = 0;

            /* 尝试解析IP地址 */
            if(strstr(ip_local_buffer, "+CIFSR:STAIP") != NULL ||
               strstr(ip_local_buffer, "+CIFSR:APIP") != NULL ||
               strstr(ip_local_buffer, "STAIP,") != NULL)
            {
              ESP_ParseIP();
              if(strlen(esp_status.ip_address) > 0)
              {
                snprintf(debug_msg, sizeof(debug_msg), "[OK] IP: %s\r\n", esp_status.ip_address);
                DEBUG_SendString(debug_msg);
                got_ip = 1;
                break;  /* 获取到IP，立即退出 */
              }
            }

            /* 收到OK就退出（不管有没有IP） */
            if(strstr(ip_local_buffer, "OK") != NULL)
            {
              break;
            }

            /* 收到ERROR也退出 */
            if(strstr(ip_local_buffer, "ERROR") != NULL)
            {
              break;
            }
          }
          ESP_DELAY(50);
        }

        if(!got_ip)
        {
          DEBUG_SendString("[WARN] No IP retrieved, but continuing...\r\n");
        }

        DEBUG_SendString("=== WiFi Connected ===\r\n\r\n");
        esp_status.connected = 1;
        return ESP_OK;
      }
    }
    ESP_DELAY(100);
  }
  
  /* 超时检查 */
  DEBUG_SendString("\r\n[TIMEOUT] 30 seconds elapsed\r\n");
  if(got_wifi_connected || got_wifi_got_ip)
  {
    /* 虽然超时了，但收到了连接成功的消息，可能是最后的OK丢失了 */
    DEBUG_SendString("[INFO] WiFi connected, verifying...\r\n");
    ESP_DELAY(1000);

    /* 快速验证连接 */
    ESP_SendATCommand("AT+CIFSR\r\n", 1000);
    ESP_DELAY(500);

    /* 简化验证 - 只需要收到任何响应即可 */
    if(esp_response_ready)
    {
      /* 尝试解析IP */
      if(strstr((char*)esp_rx_buffer, "+CIFSR:STAIP") != NULL ||
         strstr((char*)esp_rx_buffer, "+CIFSR:APIP") != NULL)
      {
        ESP_ParseIP();
        if(strlen(esp_status.ip_address) > 0)
        {
          snprintf(debug_msg, sizeof(debug_msg), "[OK] IP: %s\r\n", esp_status.ip_address);
          DEBUG_SendString(debug_msg);
        }
      }
      esp_response_ready = 0;
    }

    DEBUG_SendString("=== WiFi Connected ===\r\n\r\n");
    esp_status.connected = 1;
    return ESP_OK;
  }
  else
  {
    DEBUG_SendString("[ERROR] No connection indicators received\r\n");
    snprintf(debug_msg, sizeof(debug_msg), "Status - Connected: %d, GotIP: %d, OK: %d\r\n\r\n",
             got_wifi_connected, got_wifi_got_ip, got_ok);
    DEBUG_SendString(debug_msg);

    /* 重要：WiFi连接超时后，ESP可能进入死锁状态，需要检测 */
    DEBUG_SendString("[INFO] Checking if ESP module is still responsive...\r\n");

    /* 发送简单AT命令测试ESP状态 */
    ESP_SendATCommand("AT\r\n", 1000);
    uint32_t test_start = HAL_GetTick();
    uint8_t esp_alive = 0;

    while(HAL_GetTick() - test_start < 2000)
    {
      if(esp_response_ready)
      {
        char test_buffer[ESP_RX_BUFFER_SIZE];
        strncpy(test_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
        test_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';
        esp_response_ready = 0;
        esp_rx_index = 0;

        if(strstr(test_buffer, "OK") != NULL)
        {
          esp_alive = 1;
          DEBUG_SendString("[OK] ESP module is still responsive\r\n");
          break;
        }
      }
      ESP_DELAY(10);
    }

    if(!esp_alive)
    {
      DEBUG_SendString("[CRITICAL] ESP module is not responding after WiFi timeout!\r\n");
      DEBUG_SendString("[CRITICAL] ESP may be in a deadlocked state\r\n");
      /* 尝试恢复 */
      ESP_DetectAndRecover();
    }
  }

  return ESP_ERROR;
}

/**
  * @brief 连接到TCP服务器
  * @param server: 服务器IP或域名
  * @param port: 端口号
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 使用AT+CIPSTART指令建立TCP连接
  */
uint8_t ESP_ConnectTCP(const char *server, uint16_t port)
{
  char cmd[128];
  
  /* 构建TCP连接指令 */
  snprintf(cmd, sizeof(cmd), "AT+CIPSTART=\"TCP\",\"%s\",%d\r\n", server, port);
  
  /* 发送连接指令 */
  ESP_SendATCommand(cmd, 5000);
  
  /* 等待连接结果 */
  if(ESP_WaitForResponse("CONNECT", 5000))
  {
    if(ESP_WaitForResponse("OK", 2000))
    {
      esp_status.tcp_connected = 1;
      return ESP_OK;
    }
  }
  
  return ESP_ERROR;
}

/**
  * @brief 发送TCP数据
  * @param data: 数据指针
  * @param len: 数据长度
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 使用AT+CIPSEND指令发送数据
  */
uint8_t ESP_SendTCPData(const char *data, uint16_t len)
{
  char cmd[32];
  
  if(!esp_status.tcp_connected)
  {
    return ESP_ERROR;
  }
  
  /* 构建发送指令 */
  snprintf(cmd, sizeof(cmd), "AT+CIPSEND=%d\r\n", len);
  
  /* 发送发送指令 */
  ESP_SendATCommand(cmd, 1000);
  
  /* 等待 '>' 提示符 */
  if(ESP_WaitForResponse(">", 1000))
  {
    /* 发送实际数据 */
    HAL_UART_Transmit(&huart2, (uint8_t*)data, len, 2000);
    
    /* 等待发送完成 */
    if(ESP_WaitForResponse("SEND OK", 5000))
    {
      return ESP_OK;
    }
  }
  
  return ESP_ERROR;
}

/**
  * @brief 发送AT指令
  * @param cmd: AT指令字符串
  * @param timeout: 发送超时时间（毫秒）
  * @retval None
  * @details 通过USART2发送AT指令到ESP模块，增强稳定性
  */
void ESP_SendATCommand(const char *cmd, uint32_t timeout)
{
  /* 1. 等待之前的操作完成和UART空闲 - 减少等待时间避免阻塞 */
  uint32_t wait_start = HAL_GetTick();
  while(esp_response_ready && (HAL_GetTick() - wait_start < 500))
  {
    ESP_DELAY(10);
  }
  
  /* 如果超过500ms仍未处理完，强制清空 */
  if(esp_response_ready)
  {
    esp_response_ready = 0;
  }

  /* 2. 给ESP模块处理时间 - 重要！避免连续发送命令导致溢出 */
  ESP_DELAY(100);

  /* 3. 重置接收状态 - 每次发送新命令前都清空缓冲区 */
  esp_rx_index = 0;
  esp_rx_complete = 0;
  esp_response_ready = 0;
  memset(esp_rx_buffer, 0, ESP_RX_BUFFER_SIZE);

  /* 4. 发送指令 - 使用更长的超时以支持长命令 */
  uint16_t cmd_len = strlen(cmd);
  HAL_UART_Transmit(&huart2, (uint8_t*)cmd, cmd_len, timeout);

  /* 5. 命令发送后，给ESP处理时间（根据命令长度动态调整） */
  if(cmd_len > 64)
  {
    ESP_DELAY(200);  /* 长命令需要更多处理时间 */
  }
  else
  {
    ESP_DELAY(50);   /* 短命令较快 */
  }

  /* 注意：这里不再启动接收中断，因为主循环中的中断回调已经处理了接收
   * ESP驱动通过检查esp_rx_complete标志来获取响应
   */
}

/**
  * @brief 清理ESP接收缓冲区
  * @param None
  * @retval None
  * @details 定期调用以清理可能的残留数据，防止缓冲区堆积
  *          当检测到长时间未处理的数据时，强制清空缓冲区
  */
void ESP_ClearBuffer(void)
{
  /* 检查是否有超时未处理的数据（超过5秒） */
  if(esp_response_ready)
  {
    uint32_t time_since_rx = HAL_GetTick() - esp_last_rx_time;
    if(time_since_rx > 5000)  /* 5秒超时 */
    {
      /* 强制清空缓冲区 */
      esp_rx_index = 0;
      esp_rx_complete = 0;
      esp_response_ready = 0;
      memset(esp_rx_buffer, 0, ESP_RX_BUFFER_SIZE);
    }
  }
  
  /* 如果缓冲区接近满，但没有收到换行符，可能是异常数据，清空 */
  if(esp_rx_index > (ESP_RX_BUFFER_SIZE - 10) && !esp_response_ready)
  {
    /* 缓冲区几乎满了但没有完整响应，清空 */
    esp_rx_index = 0;
    memset(esp_rx_buffer, 0, ESP_RX_BUFFER_SIZE);
  }
}

/**
  * @brief 等待ESP响应
  * @param expected: 期望的响应字符串
  * @param timeout: 超时时间（毫秒）
  * @retval 1: 收到期望响应, 0: 超时或错误
  * @details 在指定时间内等待特定的响应字符串
  */
uint8_t ESP_WaitForResponse(const char *expected, uint32_t timeout)
{
  uint32_t start_time = HAL_GetTick();
  uint8_t found_expected = 0;

  while(HAL_GetTick() - start_time < timeout)
  {
    if(esp_response_ready)
    {
      /* 立即保存响应到本地缓冲区，避免被新数据覆盖 */
      char local_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志和索引，允许接收新数据 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 检查是否包含期望的响应 */
      if(strstr(local_buffer, expected) != NULL)
      {
        found_expected = 1;
      }

      /* 检查是否包含错误 */
      if(strstr(local_buffer, "ERROR") != NULL)
      {
        return 0;
      }

      /* 检查是否收到OK（表示指令完成） */
      if(strstr(local_buffer, "OK") != NULL)
      {
        /* 如果之前找到了期望的响应，返回成功 */
        if(found_expected)
        {
          return 1;
        }
        /* 如果只收到OK但没有期望的响应，继续等待 */
        /* 因为多行响应可能分多次到达 */
        continue;
      }
    }
    ESP_DELAY(10);
  }

  return found_expected;  // 如果找到了期望的响应，即使超时也返回成功
}

/**
  * @brief 解析IP地址
  * @param None
  * @retval None
  * @details 从响应中提取IP地址，支持多种响应格式
  */
void ESP_ParseIP(void)
{
  char *p1, *p2;
  
  /* 尝试解析AT+CIFSR的响应格式：+CIFSR:IPDEN,"192.168.31.95" */
  p1 = strstr((char*)esp_rx_buffer, "+CIFSR:IPDEN,\"");
  if(p1)
  {
    p1 += 15;  // 跳过 "+CIFSR:IPDEN,\""
    p2 = strchr(p1, '\"');
    if(p2)
    {
      int len = p2 - p1;
      if(len < 20 && len > 0)
      {
        strncpy(esp_status.ip_address, p1, len);
        esp_status.ip_address[len] = '\0';
        return;
      }
    }
  }
  
  /* 尝试解析AT+CIFSR的另一种格式：+CIFSR:STAIP,"192.168.31.95" */
  p1 = strstr((char*)esp_rx_buffer, "+CIFSR:STAIP,\"");
  if(p1)
  {
    p1 += 15;  // 跳过 "+CIFSR:STAIP,\""
    p2 = strchr(p1, '\"');
    if(p2)
    {
      int len = p2 - p1;
      if(len < 20 && len > 0)
      {
        strncpy(esp_status.ip_address, p1, len);
        esp_status.ip_address[len] = '\0';
        return;
      }
    }
  }
  
  /* 尝试解析AT+CIPSTA的响应格式：+CIPSTA:ip:"192.168.31.95" */
  p1 = strstr((char*)esp_rx_buffer, "+CIPSTA:ip:\"");
  if(p1)
  {
    p1 += 12;  // 跳过 "+CIPSTA:ip:\""
    p2 = strchr(p1, '\"');
    if(p2)
    {
      int len = p2 - p1;
      if(len < 20 && len > 0)
      {
        strncpy(esp_status.ip_address, p1, len);
        esp_status.ip_address[len] = '\0';
        return;
      }
    }
  }
  
  /* 尝试解析AT+CIPSTA的另一种格式：+CIPSTA:ip:192.168.31.95（无引号） */
  p1 = strstr((char*)esp_rx_buffer, "+CIPSTA:ip:");
  if(p1)
  {
    p1 += 11;  // 跳过 "+CIPSTA:ip:"
    /* 跳过可能的空格 */
    while(*p1 == ' ') p1++;
    
    /* 查找下一个非数字和点的字符 */
    p2 = p1;
    while(*p2 && (*p2 == '.' || (*p2 >= '0' && *p2 <= '9')))
    {
      p2++;
    }
    if(p2 > p1)
    {
      int len = p2 - p1;
      if(len < 20 && len > 0)
      {
        strncpy(esp_status.ip_address, p1, len);
        esp_status.ip_address[len] = '\0';
        return;
      }
    }
  }
  
  /* 尝试解析AT+CIFSR的另一种格式：+CIFSR:STAIP,192.168.31.95（无引号） */
  p1 = strstr((char*)esp_rx_buffer, "+CIFSR:STAIP,");
  if(p1)
  {
    p1 += 14;  // 跳过 "+CIFSR:STAIP,"
    /* 跳过可能的空格 */
    while(*p1 == ' ') p1++;
    
    /* 查找下一个非数字和点的字符 */
    p2 = p1;
    while(*p2 && (*p2 == '.' || (*p2 >= '0' && *p2 <= '9')))
    {
      p2++;
    }
    if(p2 > p1)
    {
      int len = p2 - p1;
      if(len < 20 && len > 0)
      {
        strncpy(esp_status.ip_address, p1, len);
        esp_status.ip_address[len] = '\0';
        return;
      }
    }
  }
}

/**
  * @brief 解析MAC地址
  * @param None
  * @retval None
  * @details 从响应中提取MAC地址
  */
void ESP_ParseMAC(void)
{
  char *p1, *p2;
  
  p1 = strstr((char*)esp_rx_buffer, "+CIPSTAMAC:\"");
  if(p1)
  {
    p1 += 12;  // 跳过 "+CIPSTAMAC:\""
    p2 = strchr(p1, '\"');
    if(p2)
    {
      int len = p2 - p1;
      if(len < 20)
      {
        strncpy(esp_status.mac_address, p1, len);
        esp_status.mac_address[len] = '\0';
      }
    }
  }
}

/**
  * @brief 处理接收到的ESP数据
  * @param None
  * @retval None
  * @details 在主循环中调用，处理ESP模块返回的数据
  * @note 特殊处理：检测MQTT接收的消息并打印
  *       MQTT消息格式: +MQTTSUBRECV=<linkID>,"<topic>",<len>,<data>
  */
void ESP_ProcessReceivedData(void)
{
  char debug_msg[512];  /* 增加缓冲区以避免truncation警告 */
  
  /* 检查是否有新数据行接收完成 */
  if(esp_rx_complete)
  {
    /* 添加字符串结束符（中断中已添加，这里确保安全） */
    esp_rx_buffer[esp_rx_index] = '\0';
    
    /* 检查是否是MQTT接收的消息 */
    /* 格式: +MQTTSUBRECV:0,"testtopic1",3,111 或 +MQTTSUBRECV=0,"testtopic1",3,"111" */
    if(strstr((char*)esp_rx_buffer, "+MQTTSUBRECV") != NULL)
    {
      /* 提取主题 */
      char topic[128] = {0};
      char message[256] = {0};
      char *topic_start = strstr((char*)esp_rx_buffer, "\"");
      
      if(topic_start)
      {
        topic_start++;  // 跳过第一个引号
        char *topic_end = strchr(topic_start, '\"');
        if(topic_end)
        {
          int topic_len = topic_end - topic_start;
          if(topic_len > 0 && topic_len < 128)
          {
            strncpy(topic, topic_start, topic_len);
            topic[topic_len] = '\0';
          }
        }
      }
      
      /* 提取消息内容 - 查找最后一个逗号后的数据 */
      /* 从后往前查找逗号，避免主题中可能包含逗号 */
      char *data_start = strrchr((char*)esp_rx_buffer, ',');
      if(data_start)
      {
        data_start++;  // 跳过逗号
        
        /* 跳过空格 */
        while(*data_start == ' ') data_start++;
        
        /* 检查是否有引号 */
        if(*data_start == '\"')
        {
          data_start++;  // 跳过引号
          char *data_end = strchr(data_start, '\"');
          if(data_end)
          {
            int data_len = data_end - data_start;
            if(data_len > 0 && data_len < 256)
            {
              strncpy(message, data_start, data_len);
              message[data_len] = '\0';
            }
          }
        }
        else
        {
          /* 没有引号，直接提取到行尾（去除\r\n） */
          char *data_end = data_start;
          while(*data_end && *data_end != '\r' && *data_end != '\n')
          {
            data_end++;
          }
          int data_len = data_end - data_start;
          if(data_len > 0 && data_len < 256)
          {
            strncpy(message, data_start, data_len);
            message[data_len] = '\0';
          }
        }
      }
      
      /* 简洁输出 - 只显示主题和消息 */
      if(strlen(topic) > 0 && strlen(message) > 0)
      {
        snprintf(debug_msg, sizeof(debug_msg), "[MQTT] %s: %s\r\n", topic, message);
        DEBUG_SendString(debug_msg);
        USART2_SendString(debug_msg);
      }
      else
      {
        /* 解析失败，显示原始数据（限制长度） */
        int buf_len = strlen((char*)esp_rx_buffer);
        if(buf_len > 200) buf_len = 200;  /* 限制最大显示长度 */
        snprintf(debug_msg, sizeof(debug_msg), "[MQTT] Raw: %.*s\r\n", buf_len, (char*)esp_rx_buffer);
        DEBUG_SendString(debug_msg);
      }
    }
    
    /* 设置响应就绪标志，让主程序处理这一行数据 */
    esp_response_ready = 1;
    
    /* 重置接收状态，准备接收下一行 */
    esp_rx_index = 0;
    esp_rx_complete = 0;
    
    return;
  }
  
  /* 检查是否有新数据到达但未完成一行（超时检测） */
  if(esp_rx_index > 0 && HAL_GetTick() - esp_last_rx_time > 50)
  {
    /* 超过50ms没有新数据，认为当前数据接收完成 */
    if(!esp_response_ready)
    {
      /* 添加字符串结束符 */
      esp_rx_buffer[esp_rx_index] = '\0';
      
      /* 检查是否是MQTT接收的消息 */
      if(strstr((char*)esp_rx_buffer, "+MQTTSUBRECV") != NULL)
      {
        /* 提取主题和消息 - 使用与上面相同的简化逻辑 */
        char topic[128] = {0};
        char message[256] = {0};
        char *topic_start = strstr((char*)esp_rx_buffer, "\"");
        
        if(topic_start)
        {
          topic_start++;
          char *topic_end = strchr(topic_start, '\"');
          if(topic_end)
          {
            int topic_len = topic_end - topic_start;
            if(topic_len > 0 && topic_len < 128)
            {
              strncpy(topic, topic_start, topic_len);
              topic[topic_len] = '\0';
            }
          }
        }
        
        /* 提取消息 - 从最后一个逗号开始 */
        char *data_start = strrchr((char*)esp_rx_buffer, ',');
        if(data_start)
        {
          data_start++;
          while(*data_start == ' ') data_start++;
          
          if(*data_start == '\"')
          {
            data_start++;
            char *data_end = strchr(data_start, '\"');
            if(data_end)
            {
              int data_len = data_end - data_start;
              if(data_len > 0 && data_len < 256)
              {
                strncpy(message, data_start, data_len);
                message[data_len] = '\0';
              }
            }
          }
          else
          {
            char *data_end = data_start;
            while(*data_end && *data_end != '\r' && *data_end != '\n')
            {
              data_end++;
            }
            int data_len = data_end - data_start;
            if(data_len > 0 && data_len < 256)
            {
              strncpy(message, data_start, data_len);
              message[data_len] = '\0';
            }
          }
        }
        
        /* 简洁输出 */
        if(strlen(topic) > 0 && strlen(message) > 0)
        {
          snprintf(debug_msg, sizeof(debug_msg), "[MQTT] %s: %s\r\n", topic, message);
          DEBUG_SendString(debug_msg);
          USART2_SendString(debug_msg);
        }
      }
      
      esp_response_ready = 1;
      esp_rx_index = 0;
    }
  }
  
  /* 确保接收中断持续运行（如果意外停止） */
  /* 注意：在HAL_UART_RxCpltCallback中已经持续重启了中断 */
  /* 这里只是为了保险起见，防止中断意外停止 */
}

/**
  * @brief 获取ESP状态
  * @param None
  * @retval ESP状态结构体指针
  * @details 返回ESP模块的当前状态信息
  */
ESP_Status_t* ESP_GetStatus(void)
{
  return &esp_status;
}

/**
  * @brief 断开TCP连接
  * @param None
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 发送AT+CIPCLOSE指令断开TCP连接
  */
uint8_t ESP_DisconnectTCP(void)
{
  ESP_SendATCommand("AT+CIPCLOSE\r\n", 1000);
  if(ESP_WaitForResponse("CLOSED", 1000))
  {
    esp_status.tcp_connected = 0;
    return ESP_OK;
  }
  return ESP_ERROR;
}

/**
  * @brief 断开WiFi连接
  * @param None
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 发送AT+CWQAP指令断开WiFi连接
  */
uint8_t ESP_DisconnectWiFi(void)
{
  ESP_SendATCommand("AT+CWQAP\r\n", 2000);
  if(ESP_WaitForResponse("OK", 2000))
  {
    esp_status.connected = 0;
    return ESP_OK;
  }
  return ESP_ERROR;
}

/**
  * @brief 重启ESP模块
  * @param None
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 发送AT+RST指令重启模块
  */
uint8_t ESP_Restart(void)
{
  ESP_SendATCommand("AT+RST\r\n", 1000);
  ESP_DELAY(2000);  // 等待重启完成
  return ESP_Init();  // 重新初始化
}

/**
  * @brief 手动查询IP地址
  * @param None
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 发送AT+CIPSTA?指令查询当前IP地址
  */
uint8_t ESP_QueryIP(void)
{
  char debug_msg[256];
  DEBUG_SendString("Querying IP address...\r\n");

  /* 等待之前可能正在进行的操作完成 */
  ESP_DELAY(500);

  /* 发送查询指令 */
  ESP_SendATCommand("AT+CIPSTA?\r\n", 1000);

  /* 等待并解析响应 */
  uint32_t start_time = HAL_GetTick();
  uint8_t got_ip = 0;
  uint8_t response_count = 0;

  /* 先等待一小段时间让ESP开始响应 */
  ESP_DELAY(200);

  while(HAL_GetTick() - start_time < 5000)
  {
    if(esp_response_ready)
    {
      response_count++;

      /* 立即保存响应到本地缓冲区，避免被新数据覆盖 */
      char local_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志和索引，允许接收新数据 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 打印收到的响应内容用于调试 */
      int resp_len = strlen(local_buffer);
      if(resp_len > 200) {
        snprintf(debug_msg, sizeof(debug_msg), "  [Response #%d] %.200s...\r\n",
                 response_count, local_buffer);
      } else {
        snprintf(debug_msg, sizeof(debug_msg), "  [Response #%d] %s\r\n",
                 response_count, local_buffer);
      }
      DEBUG_SendString(debug_msg);

      /* 检查所有可能的IP地址格式 */
      if(strstr(local_buffer, "+CIPSTA:ip:") != NULL)
      {
        ESP_ParseIP();
        if(strlen(esp_status.ip_address) > 0)
        {
          snprintf(debug_msg, sizeof(debug_msg), "[OK] IP Address: %s\r\n",
                   esp_status.ip_address);
          DEBUG_SendString(debug_msg);
          got_ip = 1;
        }
      }
      else if(strstr(local_buffer, "ip:") != NULL)
      {
        /* 尝试查找不带+CIPSTA:前缀的ip: */
        char *p1 = strstr(local_buffer, "ip:");
        if(p1)
        {
          p1 += 3;  // 跳过 "ip:"
          /* 跳过空格和引号 */
          while(*p1 == ' ' || *p1 == '"') p1++;

          /* 提取IP地址 */
          char *p2 = p1;
          while(*p2 && (*p2 == '.' || (*p2 >= '0' && *p2 <= '9')))
          {
            p2++;
          }

          int len = p2 - p1;
          if(len >= 7 && len < 20)  // 最小IP长度如 1.1.1.1
          {
            strncpy(esp_status.ip_address, p1, len);
            esp_status.ip_address[len] = '\0';
            snprintf(debug_msg, sizeof(debug_msg), "[OK] IP Address: %s\r\n",
                     esp_status.ip_address);
            DEBUG_SendString(debug_msg);
            got_ip = 1;
          }
        }
      }

      /* 检查OK */
      if(strstr(local_buffer, "OK") != NULL)
      {
        if(got_ip)
        {
          return ESP_OK;
        }
        /* 即使没有IP，也继续等待可能的其他行 */
        if(response_count >= 5)  // 最多等待5行响应
        {
          break;
        }
      }

      /* 检查错误 */
      if(strstr(local_buffer, "ERROR") != NULL)
      {
        DEBUG_SendString("[WARN] CIPSTA query failed, trying CIFSR...\r\n");
        /* 如果AT+CIPSTA?失败，尝试用AT+CIFSR */
        ESP_DELAY(500);
        ESP_SendATCommand("AT+CIFSR\r\n", 2000);

        uint32_t cifsr_start = HAL_GetTick();
        while(HAL_GetTick() - cifsr_start < 3000)
        {
          if(esp_response_ready)
          {
            char cifsr_buffer[ESP_RX_BUFFER_SIZE];
            strncpy(cifsr_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
            cifsr_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';
            esp_response_ready = 0;
            esp_rx_index = 0;

            /* 尝试解析IP地址 */
            if(strstr(cifsr_buffer, "+CIFSR:STAIP") != NULL ||
               strstr(cifsr_buffer, "+CIFSR:APIP") != NULL ||
               strstr(cifsr_buffer, "STAIP,") != NULL)
            {
              ESP_ParseIP();
              if(strlen(esp_status.ip_address) > 0)
              {
                snprintf(debug_msg, sizeof(debug_msg), "[OK] IP (CIFSR): %s\r\n",
                         esp_status.ip_address);
                DEBUG_SendString(debug_msg);
                return ESP_OK;
              }
            }

            if(strstr(cifsr_buffer, "OK") != NULL)
            {
              break;
            }
            if(strstr(cifsr_buffer, "ERROR") != NULL)
            {
              break;
            }
          }
          ESP_DELAY(10);
        }
        break;
      }
    }
    ESP_DELAY(10);
  }

  /* 打印统计信息 */
  snprintf(debug_msg, sizeof(debug_msg), "[INFO] Query completed: %d response lines, got_ip=%d\r\n",
           response_count, got_ip);
  DEBUG_SendString(debug_msg);

  return got_ip ? ESP_OK : ESP_ERROR;
}

/**
  * @brief 配置MQTT连接参数
  * @param client_id: MQTT客户端ID
  * @param username: MQTT用户名
  * @param password: MQTT密码
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 配置MQTT用户参数，使用AT+MQTTUSERCFG指令
  *          指令格式: AT+MQTTUSERCFG=<linkID>,<scheme>,<client_id>,<username>,<password>,<cert_key_ID>,<CA_ID>,<path>
  *          参数说明:
  *          - linkID: 链接ID (0-5), 使用0
  *          - scheme: 认证方式 (0=无认证, 1=用户名密码, 2=客户端证书), 使用1
  *          - client_id: 客户端ID
  *          - username: MQTT用户名
  *          - password: MQTT密码
  *          - cert_key_ID: 证书密钥ID (0-255), 使用0
  *          - CA_ID: CA证书ID (0-255), 使用0
  *          - path: MQTT路径, 使用空字符串
  */
uint8_t ESP_ConfigureMQTT(const char *client_id, const char *username, const char *password)
{
  char cmd[256];
  char debug_msg[512];  /* 增加缓冲区以避免truncation警告 */

  DEBUG_SendString("\r\n=== MQTT Configuration ===\r\n");

  /* 打印配置信息 */
  snprintf(debug_msg, sizeof(debug_msg), "Client ID: %s\r\n", client_id);
  DEBUG_SendString(debug_msg);
  snprintf(debug_msg, sizeof(debug_msg), "Username: %s\r\n", username);
  DEBUG_SendString(debug_msg);

  /* 在配置MQTT前，先确认ESP模块仍然响应 */
  DEBUG_SendString("Step 0: Verifying ESP module is ready...\r\n");
  ESP_SendATCommand("AT\r\n", 1000);

  uint32_t check_start = HAL_GetTick();
  uint8_t esp_ready = 0;
  while(HAL_GetTick() - check_start < 2000)
  {
    if(esp_response_ready)
    {
      char check_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(check_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      check_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';
      esp_response_ready = 0;
      esp_rx_index = 0;

      if(strstr(check_buffer, "OK") != NULL)
      {
        esp_ready = 1;
        DEBUG_SendString("[OK] ESP module is ready\r\n");
        break;
      }
    }
    ESP_DELAY(10);
  }

  if(!esp_ready)
  {
    DEBUG_SendString("[ERROR] ESP module not responding - cannot configure MQTT\r\n");
    DEBUG_SendString("=== MQTT Configuration Failed ===\r\n\r\n");
    return ESP_ERROR;
  }

  ESP_DELAY(500);  /* 给ESP模块准备时间 */
  
  /* 先尝试断开之前可能存在的MQTT连接 */
  DEBUG_SendString("Step 1: Disconnecting previous MQTT connection (if any)...\r\n");
  ESP_SendATCommand("AT+MQTTCLEAN=0\r\n", 3000);

  /* 等待MQTTCLEAN命令完成 */
  uint32_t clean_start = HAL_GetTick();
  while(HAL_GetTick() - clean_start < 5000)
  {
    if(esp_response_ready)
    {
      /* 立即保存响应到本地缓冲区 */
      char clean_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(clean_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      clean_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 检查是否收到OK或ERROR */
      if(strstr(clean_buffer, "OK") != NULL ||
         strstr(clean_buffer, "ERROR") != NULL)
      {
        break;
      }
    }
    ESP_DELAY(10);
  }

  ESP_DELAY(1000);  /* 给ESP模块充足的时间处理清理操作 */

  /* 构建MQTT配置指令 */
  /* 尝试不同的scheme参数值 */
  /* scheme参数说明: 1=TCP, 2=TLS(无证书验证), 3=TLS(验证服务器证书), 4=TLS(提供客户端证书), 5=TLS(双向验证) */
  /* 对于无SSL的连接，使用scheme=1 */
  snprintf(cmd, sizeof(cmd), "AT+MQTTUSERCFG=0,1,\"%s\",\"%s\",\"%s\",0,0,\"\"\r\n",
           client_id, username, password);

  snprintf(debug_msg, sizeof(debug_msg), "Step 2: Sending command: %s", cmd);
  DEBUG_SendString(debug_msg);

  /* 发送配置指令 - 增加超时到5秒，因为这是长命令 */
  ESP_SendATCommand(cmd, 5000);

  /* 等待响应 - 增加超时时间并显示详细错误信息 */
  uint32_t start_time = HAL_GetTick();
  uint8_t got_response = 0;
  uint32_t last_rx_time = HAL_GetTick();

  while(HAL_GetTick() - start_time < 10000)  /* 增加到10秒 */
  {
    if(esp_response_ready)
    {
      got_response = 1;

      /* 立即保存响应到本地缓冲区 */
      char cfg_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(cfg_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      cfg_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 打印收到的响应（限制长度） */
      int resp_len = strlen(cfg_buffer);
      if(resp_len > 200) resp_len = 200;  /* 限制最大显示长度 */
      snprintf(debug_msg, sizeof(debug_msg), "ESP Response: %.*s\r\n", resp_len, cfg_buffer);
      DEBUG_SendString(debug_msg);

      if(strstr(cfg_buffer, "OK") != NULL)
      {
        DEBUG_SendString("[OK] MQTT configuration successful\r\n");
        DEBUG_SendString("=== MQTT Configuration Complete ===\r\n\r\n");
        return ESP_OK;
      }

      if(strstr(cfg_buffer, "ERROR") != NULL)
      {
        DEBUG_SendString("[ERROR] MQTT configuration command returned ERROR\r\n");
        DEBUG_SendString("Possible reasons:\r\n");
        DEBUG_SendString("  - Invalid scheme parameter\r\n");
        DEBUG_SendString("  - MQTT already configured (try AT+MQTTCLEAN=0 first)\r\n");
        DEBUG_SendString("  - Firmware doesn't support this AT command\r\n");
        DEBUG_SendString("=== MQTT Configuration Failed ===\r\n\r\n");
        return ESP_ERROR;
      }
    }

    /* 检查是否有数据在缓冲区但很久没收到新数据（可能缺少换行符） */
    if(esp_rx_index > 0 && (HAL_GetTick() - last_rx_time > 500))
    {
      DEBUG_SendString("[INFO] Partial response received without line ending, processing...\r\n");

      /* 手动完成接收 */
      esp_rx_buffer[esp_rx_index] = '\0';
      char cfg_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(cfg_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      cfg_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 重置缓冲区 */
      esp_rx_index = 0;

      /* 打印收到的响应 */
      int resp_len = strlen(cfg_buffer);
      if(resp_len > 200) resp_len = 200;
      snprintf(debug_msg, sizeof(debug_msg), "ESP Response (partial): %.*s\r\n", resp_len, cfg_buffer);
      DEBUG_SendString(debug_msg);

      if(strstr(cfg_buffer, "OK") != NULL)
      {
        DEBUG_SendString("[OK] MQTT configuration successful (partial response)\r\n");
        DEBUG_SendString("=== MQTT Configuration Complete ===\r\n\r\n");
        return ESP_OK;
      }

      if(strstr(cfg_buffer, "ERROR") != NULL)
      {
        DEBUG_SendString("[ERROR] MQTT configuration command returned ERROR\r\n");
        DEBUG_SendString("=== MQTT Configuration Failed ===\r\n\r\n");
        return ESP_ERROR;
      }

      /* 处理了部分响应但不是OK或ERROR，继续等待 */
      last_rx_time = HAL_GetTick();
    }

    /* 更新最后接收时间 */
    if(esp_last_rx_time > last_rx_time)
    {
      last_rx_time = esp_last_rx_time;
    }

    ESP_DELAY(10);
  }
  
  if(!got_response)
  {
    DEBUG_SendString("[ERROR] No response from ESP module (timeout)\r\n");

    /* 添加UART接收缓冲区诊断信息 */
    snprintf(debug_msg, sizeof(debug_msg),
             "[DIAGNOSTIC] esp_rx_index=%d, esp_rx_complete=%d, esp_response_ready=%d\r\n",
             esp_rx_index, esp_rx_complete, esp_response_ready);
    DEBUG_SendString(debug_msg);

    if(esp_rx_index > 0)
    {
      snprintf(debug_msg, sizeof(debug_msg),
               "[DIAGNOSTIC] Partial data in buffer (%d bytes): %.*s\r\n",
               esp_rx_index, esp_rx_index > 50 ? 50 : esp_rx_index, (char*)esp_rx_buffer);
      DEBUG_SendString(debug_msg);
    }
    else
    {
      DEBUG_SendString("[DIAGNOSTIC] RX buffer completely empty - ESP may not be responding\r\n");
    }

    DEBUG_SendString("[TROUBLESHOOTING]\r\n");
    DEBUG_SendString("1. Check ESP module power (3.3V, 500mA minimum)\r\n");
    DEBUG_SendString("2. Verify UART TX/RX connections (not reversed)\r\n");
    DEBUG_SendString("3. Ensure ESP module has booted (wait 2-3 seconds after power)\r\n");
    DEBUG_SendString("4. Check if other commands are blocking UART communication\r\n");
    DEBUG_SendString("5. Try resetting ESP module or power cycling\r\n");
  }
  else
  {
    DEBUG_SendString("[ERROR] Unexpected response or timeout\r\n");
  }

  DEBUG_SendString("=== MQTT Configuration Failed ===\r\n\r\n");
  return ESP_ERROR;
}

/**
  * @brief 连接到MQTT服务器
  * @param server: MQTT服务器地址（IP或域名）
  * @param port: MQTT服务器端口
  * @param enable_ssl: 是否启用SSL (0=不启用, 1=启用)
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 使用AT+MQTTCONN指令连接MQTT服务器
  *          指令格式: AT+MQTTCONN=<linkID>,"<host>",<port>,<SSL>
  *          参数说明:
  *          - linkID: 链接ID (0-5), 使用0
  *          - host: MQTT服务器地址
  *          - port: MQTT服务器端口
  *          - SSL: SSL标志 (0=不使用SSL, 1=使用SSL), 根据参数设置
  * @note 连接过程:
  *       1. 发送AT+MQTTCONN指令
  *       2. 等待CONNECT确认（可能需要几秒）
  *       3. 某些固件版本只返回CONNECT，不返回OK
  */
uint8_t ESP_ConnectMQTT(const char *server, uint16_t port, uint8_t enable_ssl)
{
  char cmd[128];
  char debug_msg[256];
  
  DEBUG_SendString("\r\n=== MQTT Connection ===\r\n");
  
  /* 构建MQTT连接指令 */
  snprintf(cmd, sizeof(cmd), "AT+MQTTCONN=0,\"%s\",%d,%d\r\n", server, port, enable_ssl);
  
  /* 打印连接信息 */
  snprintf(debug_msg, sizeof(debug_msg), "Server: %s\r\n", server);
  DEBUG_SendString(debug_msg);
  snprintf(debug_msg, sizeof(debug_msg), "Port: %d\r\n", port);
  DEBUG_SendString(debug_msg);
  snprintf(debug_msg, sizeof(debug_msg), "SSL: %s\r\n", enable_ssl ? "Enabled" : "Disabled");
  DEBUG_SendString(debug_msg);
  snprintf(debug_msg, sizeof(debug_msg), "Command: %.100s", cmd);
  DEBUG_SendString(debug_msg);
  
  /* 注意：不要在这里调用AT+MQTTCLEAN，因为它可能会清除MQTT配置 */
  /* AT+MQTTCLEAN已经在ESP_ConfigureMQTT中调用过了 */
  
  DEBUG_SendString("Sending AT+MQTTCONN command...\r\n");
  
  /* 清空接收缓冲区 */
  esp_response_ready = 0;
  memset(esp_rx_buffer, 0, sizeof(esp_rx_buffer));
  esp_rx_index = 0;
  
  /* 发送连接指令 */
  ESP_SendATCommand(cmd, 1000);
  
  /* 等待连接结果 - MQTT连接可能需要几秒钟 */
  /* 某些ESP固件版本在MQTT连接后只返回CONNECT，不返回OK */
  uint32_t start_time = HAL_GetTick();
  uint8_t got_connect = 0;
  uint8_t got_error = 0;
  uint8_t response_count = 0;
  uint32_t last_rx_time = HAL_GetTick();

  /* 最多等待20秒（MQTT连接可能需要更长时间） */
  while(HAL_GetTick() - start_time < 20000)
  {
    if(esp_response_ready)
    {
      response_count++;

      /* 立即保存响应到本地缓冲区 */
      char conn_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(conn_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      conn_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 打印响应（限制长度） */
      if(response_count <= 10)  /* 打印前10个响应以便调试 */
      {
        int resp_len = strlen(conn_buffer);
        if(resp_len > 100) resp_len = 100;
        snprintf(debug_msg, sizeof(debug_msg), "[Response #%d]: %.*s\r\n",
                 response_count, resp_len, conn_buffer);
        DEBUG_SendString(debug_msg);
      }

      /* 检查是否收到CONNECT */
      if(strstr(conn_buffer, "CONNECT") != NULL)
      {
        got_connect = 1;
        DEBUG_SendString("[OK] MQTT CONNECT received!\r\n");
      }

      /* 检查是否收到ERROR */
      if(strstr(conn_buffer, "ERROR") != NULL)
      {
        got_error = 1;
        DEBUG_SendString("[WARN] Received ERROR response\r\n");
        snprintf(debug_msg, sizeof(debug_msg), "Error details: %.100s\r\n", conn_buffer);
        DEBUG_SendString(debug_msg);
      }

      /* 检查是否收到OK（某些固件版本会返回OK） */
      if(strstr(conn_buffer, "OK") != NULL && got_connect)
      {
        DEBUG_SendString("[OK] Connection confirmed with OK\r\n");
      }

      /* 连接成功的判断条件：收到CONNECT */
      if(got_connect)
      {
        DEBUG_SendString("\r\n*** MQTT Connection Successful! ***\r\n");
        DEBUG_SendString("=== MQTT Connection Complete ===\r\n\r\n");
        esp_status.tcp_connected = 1;
        return ESP_OK;
      }

      /* 如果收到ERROR且没有CONNECT，立即判定失败 */
      if(got_error && !got_connect)
      {
        DEBUG_SendString("=== MQTT Connection Failed ===\r\n\r\n");
        return ESP_ERROR;
      }
    }

    /* 检查是否有数据在缓冲区但很久没收到新数据（可能缺少换行符） */
    if(esp_rx_index > 0 && (HAL_GetTick() - last_rx_time > 500))
    {
      /* 手动完成接收 */
      esp_rx_buffer[esp_rx_index] = '\0';
      char conn_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(conn_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      conn_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 重置缓冲区 */
      esp_rx_index = 0;

      /* 打印部分响应 */
      int resp_len = strlen(conn_buffer);
      if(resp_len > 100) resp_len = 100;
      snprintf(debug_msg, sizeof(debug_msg), "[Partial #%d]: %.*s\r\n",
               response_count + 1, resp_len, conn_buffer);
      DEBUG_SendString(debug_msg);

      /* 检查是否包含CONNECT */
      if(strstr(conn_buffer, "CONNECT") != NULL)
      {
        got_connect = 1;
        DEBUG_SendString("[OK] MQTT CONNECT received (partial)!\r\n");
      }

      /* 检查是否包含ERROR */
      if(strstr(conn_buffer, "ERROR") != NULL)
      {
        got_error = 1;
        DEBUG_SendString("[WARN] Received ERROR (partial)\r\n");
      }

      /* 如果收到CONNECT，返回成功 */
      if(got_connect)
      {
        DEBUG_SendString("\r\n*** MQTT Connection Successful! ***\r\n");
        DEBUG_SendString("=== MQTT Connection Complete ===\r\n\r\n");
        esp_status.tcp_connected = 1;
        return ESP_OK;
      }

      /* 处理了部分响应，更新时间 */
      last_rx_time = HAL_GetTick();
    }

    /* 更新最后接收时间 */
    if(esp_last_rx_time > last_rx_time)
    {
      last_rx_time = esp_last_rx_time;
    }

    ESP_DELAY(100);
  }

  /* 超时检查 */
  DEBUG_SendString("\r\n[TIMEOUT] 20 seconds elapsed\r\n");
  snprintf(debug_msg, sizeof(debug_msg), "Total responses received: %d\r\n", response_count);
  DEBUG_SendString(debug_msg);

  if(got_connect)
  {
    DEBUG_SendString("[INFO] Connection successful\r\n");
    esp_status.tcp_connected = 1;
    return ESP_OK;
  }
  else
  {
    DEBUG_SendString("[ERROR] No valid connection response received\r\n");
    DEBUG_SendString("Possible issues:\r\n");
    DEBUG_SendString("  1. Server unreachable\r\n");
    DEBUG_SendString("  2. Port blocked or wrong\r\n");
    DEBUG_SendString("  3. ESP-01S firmware doesn't support MQTT\r\n");
    DEBUG_SendString("  4. WiFi connection lost\r\n");

    /* 重要：MQTT连接超时后，检测ESP是否还活着 */
    DEBUG_SendString("[INFO] Checking if ESP module is still responsive...\r\n");
    ESP_SendATCommand("AT\r\n", 1000);

    uint32_t test_start = HAL_GetTick();
    uint8_t esp_alive = 0;

    while(HAL_GetTick() - test_start < 2000)
    {
      if(esp_response_ready)
      {
        char test_buffer[ESP_RX_BUFFER_SIZE];
        strncpy(test_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
        test_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';
        esp_response_ready = 0;
        esp_rx_index = 0;

        if(strstr(test_buffer, "OK") != NULL)
        {
          esp_alive = 1;
          DEBUG_SendString("[OK] ESP module is still responsive\r\n");
          break;
        }
      }
      ESP_DELAY(10);
    }

    if(!esp_alive)
    {
      DEBUG_SendString("[CRITICAL] ESP module is not responding after MQTT timeout!\r\n");
      DEBUG_SendString("[CRITICAL] ESP may be in a deadlocked state\r\n");
      /* 尝试恢复 */
      ESP_DetectAndRecover();
    }

    DEBUG_SendString("=== MQTT Connection Failed ===\r\n\r\n");
    return ESP_ERROR;
  }
}

/**
  * @brief 订阅MQTT主题
  * @param topic: 要订阅的主题名称
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 使用AT+MQTTSUB指令订阅MQTT主题
  *          指令格式: AT+MQTTSUB=<linkID>,"<topic>",<qos>
  *          参数说明:
  *          - linkID: 链接ID (0-5), 使用0
  *          - topic: 订阅的主题名称
  *          - qos: 服务质量等级 (0=最多一次, 1=至少一次, 2=只有一次), 使用1
  * @note 订阅成功后，ESP模块会自动接收该主题的消息
  *       收到的消息格式: +MQTTSUBRECV=<linkID>,"<topic>",<len>,<data>
  */
uint8_t ESP_SubscribeMQTT(const char *topic)
{
  char cmd[128];
  char debug_msg[512];  /* 增加缓冲区以避免truncation警告 */
  
  DEBUG_SendString("\r\n=== MQTT Subscribe ===\r\n");
  
  /* 等待MQTT连接稳定 - 非常重要！ */
  /* DEBUG_SendString("Waiting for MQTT connection to stabilize...\r\n"); */
  ESP_DELAY(2000);  // 等待2秒让MQTT连接完全建立

  /* 先清除缓冲区中的任何残留数据 */
  uint32_t clear_start = HAL_GetTick();
  while(esp_response_ready && (HAL_GetTick() - clear_start < 1000))
  {
    /* 读取并丢弃旧数据 */
    esp_response_ready = 0;
    ESP_DELAY(10);
  }

  /* 构建订阅指令 */
  snprintf(cmd, sizeof(cmd), "AT+MQTTSUB=0,\"%s\",1\r\n", topic);

  /* 打印订阅信息 - 精简为一条 */
  snprintf(debug_msg, sizeof(debug_msg), "[MQTT] Subscribing to: %s\r\n", topic);
  DEBUG_SendString(debug_msg);

  /* 先清除可能的残留响应 */
  clear_start = HAL_GetTick();
  while(esp_response_ready && (HAL_GetTick() - clear_start < 500))
  {
    /* DEBUG_SendString("  Clearing old response...\r\n"); */
    esp_response_ready = 0;
    ESP_DELAY(20);
  }

  /* 发送订阅指令 */
  ESP_SendATCommand(cmd, 1000);
  
  /* 等待订阅结果 - 订阅通常很快，几秒内完成 */
  uint32_t start_time = HAL_GetTick();
  uint8_t got_ok = 0;
  uint8_t response_count = 0;
  
  /* 最多等待10秒（增加超时时间） */
  while(HAL_GetTick() - start_time < 10000)
  {
    if(esp_response_ready)
    {
      response_count++;
      
      /* 打印收到的响应内容用于调试（只打印前3个响应，避免刷屏） */
      if(response_count <= 3)
      {
        int esp_len = strlen((char*)esp_rx_buffer);
        if(esp_len > 100) {
          snprintf(debug_msg, sizeof(debug_msg), "[ESP Response #%d]: %.100s...\r\n", response_count, (char*)esp_rx_buffer);
        } else {
          snprintf(debug_msg, sizeof(debug_msg), "[ESP Response #%d]: %.*s\r\n", response_count, esp_len, (char*)esp_rx_buffer);
        }
        DEBUG_SendString(debug_msg);
      }
      else if(response_count == 4)
      {
        DEBUG_SendString("[INFO] More responses received, suppressing output...\r\n");
      }
      
      /* 检查是否包含命令回显（去除回显部分） */
      char *response_start = (char*)esp_rx_buffer;
      
      /* 查找命令回显 - 注意：回显可能不完整或格式不同 */
      char *echo_end = strstr((char*)esp_rx_buffer, "AT+MQTTSUB");
      if(echo_end)
      {
        /* 跳过命令回显部分，查找下一个非命令字符 */
        char *cmd_end = echo_end;
        while(*cmd_end && *cmd_end != '\r' && *cmd_end != '\n' && 
              *cmd_end != 'E' && *cmd_end != 'O' && *cmd_end != 'S')
        {
          cmd_end++;
        }
        
        /* 现在cmd_end指向回显结束位置，可能是ERROR、OK或其他 */
        response_start = cmd_end;
        
        /* 跳过可能的空格和换行 */
        while(*response_start == '\r' || *response_start == '\n' || *response_start == ' ')
        {
          response_start++;
        }
        
        /* 如果回显后还有内容，重新检查 */
        if(*response_start != '\0')
        {
          /* 重新检查去除回显后的内容 */
          if(strstr(response_start, "OK") != NULL)
          {
            got_ok = 1;
            DEBUG_SendString("[OK] Subscription successful (after removing echo)\r\n");
            DEBUG_SendString("=== MQTT Subscribe Complete ===\r\n\r\n");
            esp_response_ready = 0;
            return ESP_OK;
          }
          
          if(strstr(response_start, "ERROR") != NULL)
          {
            DEBUG_SendString("[ERROR] Subscription failed (after removing echo)\r\n");
            DEBUG_SendString("=== MQTT Subscribe Failed ===\r\n\r\n");
            esp_response_ready = 0;
            return ESP_ERROR;
          }
        }
      }
      
      /* 也检查原始响应中的ERROR（即使没有回显） */
      if(strstr((char*)esp_rx_buffer, "ERROR") != NULL && !got_ok)
      {
        /* 检查ERROR是否在命令之后（可能是命令回显+ERROR） */
        char *error_pos = strstr((char*)esp_rx_buffer, "ERROR");
        char *at_pos = strstr((char*)esp_rx_buffer, "AT+");
        
        if(at_pos && error_pos && error_pos > at_pos)
        {
          /* 这是命令回显+ERROR的情况 */
          DEBUG_SendString("[ERROR] Command failed (echo + ERROR)\r\n");
          DEBUG_SendString("=== MQTT Subscribe Failed ===\r\n\r\n");
          esp_response_ready = 0;
          return ESP_ERROR;
        }
        else if(!at_pos && error_pos)
        {
          /* 这是纯ERROR响应 */
          DEBUG_SendString("[ERROR] Subscription failed\r\n");
          DEBUG_SendString("=== MQTT Subscribe Failed ===\r\n\r\n");
          esp_response_ready = 0;
          return ESP_ERROR;
        }
      }
      
      /* 检查是否收到OK */
      if(strstr((char*)esp_rx_buffer, "OK") != NULL)
      {
        got_ok = 1;
        DEBUG_SendString("[OK] Subscription successful\r\n");
        DEBUG_SendString("=== MQTT Subscribe Complete ===\r\n\r\n");
        esp_response_ready = 0;
        return ESP_OK;
      }
      
      /* 检查是否收到SEND OK（某些固件版本使用此响应） */
      if(strstr((char*)esp_rx_buffer, "SEND OK") != NULL)
      {
        got_ok = 1;
        DEBUG_SendString("[SEND OK] Subscription successful\r\n");
        DEBUG_SendString("=== MQTT Subscribe Complete ===\r\n\r\n");
        esp_response_ready = 0;
        return ESP_OK;
      }
      
      /* 检查是否收到ALREADY CONNECTED（连接已存在） */
      if(strstr((char*)esp_rx_buffer, "ALREADY CONNECTED") != NULL)
      {
        got_ok = 1;
        DEBUG_SendString("[INFO] Already connected, continuing\r\n");
        DEBUG_SendString("=== MQTT Subscribe Complete ===\r\n\r\n");
        esp_response_ready = 0;
        return ESP_OK;
      }
      
      /* 检查是否收到ERROR */
      if(strstr((char*)esp_rx_buffer, "ERROR") != NULL)
      {
        if(!got_ok)
        {
          DEBUG_SendString("[ERROR] Subscription failed\r\n");
          DEBUG_SendString("=== MQTT Subscribe Failed ===\r\n\r\n");
          esp_response_ready = 0;
          return ESP_ERROR;
        }
      }
      
      /* 检查是否是其他有效响应（非空，非纯换行） */
      if(!got_ok && response_count == 1)
      {
        /* 第一次收到响应，检查内容 */
        int esp_len = strlen((char*)esp_rx_buffer);
        if(esp_len > 0)
        {
          /* 如果收到的是纯换行或空格，忽略 */
          uint8_t all_whitespace = 1;
          for(int i = 0; i < esp_len; i++)
          {
            if(esp_rx_buffer[i] != '\r' && esp_rx_buffer[i] != '\n' && esp_rx_buffer[i] != ' ')
            {
              all_whitespace = 0;
              break;
            }
          }
          
          if(!all_whitespace)
          {
            DEBUG_SendString("[INFO] Received first response, continuing to wait for OK...\r\n");
          }
        }
      }
      
      esp_response_ready = 0;
    }
    ESP_DELAY(100);
  }
  
  /* 超时处理 */
  DEBUG_SendString("\r\n[TIMEOUT] Subscription timeout after 10 seconds\r\n");
  snprintf(debug_msg, sizeof(debug_msg), "Received %d responses, got OK: %d\r\n", response_count, got_ok);
  DEBUG_SendString(debug_msg);
  
  if(got_ok)
  {
    DEBUG_SendString("[INFO] Subscription successful (timeout after OK)\r\n");
    return ESP_OK;
  }
  else if(response_count > 0)
  {
    /* 如果收到了响应但没有OK，可能需要更长的等待时间 */
    DEBUG_SendString("[WARNING] Received responses but no OK, subscription may still succeed\r\n");
    DEBUG_SendString("[INFO] This may be normal for some ESP firmware versions\r\n");
    DEBUG_SendString("=== MQTT Subscribe Complete (with warnings) ===\r\n\r\n");
    return ESP_OK;
  }
  else
  {
    DEBUG_SendString("[ERROR] Subscription failed - no response received\r\n");
    DEBUG_SendString("=== MQTT Subscribe Failed ===\r\n\r\n");
    return ESP_ERROR;
  }
}

/**
  * @brief 检查MQTT连接状态
  * @retval ESP_OK: 已连接, ESP_ERROR: 未连接
  * @details 通过发送一个测试性的MQTT发布来检查连接状态
  *          如果发布成功，说明MQTT连接正常
  *          这种方法比AT+MQTTCONN?查询更可靠
  * @note 使用特殊的测试主题，避免影响正常业务数据
  */
uint8_t ESP_CheckMQTTConnection(void)
{
  /* 发送一个心跳测试消息来验证连接状态 */
  /* 使用系统自带的主题和简单的内容，发布超时时间短一些 */
  uint8_t result = ESP_PublishMQTT("diantiTopic", "ping");

  /* 如果发布成功，说明MQTT连接正常 */
  if(result == ESP_OK)
  {
    return ESP_OK;
  }

  /* 发布失败，可能连接已断开 */
  return ESP_ERROR;
}

/**
  * @brief 发布MQTT消息
  * @param topic: 发布消息的主题名称
  * @param message: 要发布的消息内容
  * @retval ESP_OK: 成功, ESP_ERROR: 失败
  * @details 使用AT+MQTTPUB指令发布MQTT消息
  *          指令格式: AT+MQTTPUB=<linkID>,"<topic>","<message>",<qos>,<retain>
  *          参数说明:
  *          - linkID: 链接ID (0-5), 使用0
  *          - topic: 发布消息的主题名称
  *          - message: 消息内容
  *          - qos: 服务质量等级 (0=最多一次, 1=至少一次, 2=只有一次), 使用1
  *          - retain: 保留标志 (0=不保留, 1=保留), 使用0
  * @note 发布成功后，ESP模块会返回SEND OK或OK
  */
uint8_t ESP_PublishMQTT(const char *topic, const char *message)
{
  char cmd[256];
  char debug_msg[512];  /* 增加缓冲区大小以避免截断警告 */

  /* 构建AT命令 */
  snprintf(cmd, sizeof(cmd), "AT+MQTTPUB=0,\"%s\",\"%s\",0,0\r\n", topic, message);

  /* 等待之前的任何操作完成 - 重要！*/
  uint32_t wait_start = HAL_GetTick();
  while(esp_response_ready && (HAL_GetTick() - wait_start < 1000))
  {
    ESP_DELAY(10);
  }

  /* 给ESP模块一些时间，确保它准备好接收新命令 */
  ESP_DELAY(100);

  /* 清空响应 */
  esp_response_ready = 0;
  memset(esp_rx_buffer, 0, sizeof(esp_rx_buffer));
  esp_rx_index = 0;

  /* 打印发送的命令和内容到调试串口 */
  snprintf(debug_msg, sizeof(debug_msg), "[MQTT] Topic: %s, Message: %s\r\n", topic, message);
  DEBUG_SendString(debug_msg);

  /* 发送发布指令 - 增加发送超时到3秒 */
  ESP_SendATCommand(cmd, 3000);

  /* 等待一小段时间让ESP处理命令 */
  ESP_DELAY(200);

  /* 等待发布结果 - 发布通常很快，几秒内完成 */
  uint32_t start_time = HAL_GetTick();
  uint8_t got_ok = 0;
  uint8_t got_send_ok = 0;
  uint8_t got_error = 0;
  uint8_t response_count = 0;

  /* 最多等待8秒 */
  while(HAL_GetTick() - start_time < 8000)
  {
    if(esp_response_ready)
    {
      response_count++;

      /* 立即保存响应到本地缓冲区，避免被新数据覆盖 */
      char local_buffer[ESP_RX_BUFFER_SIZE];
      strncpy(local_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
      local_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

      /* 立即重置标志和索引，允许接收新数据 */
      esp_response_ready = 0;
      esp_rx_index = 0;

      /* 打印收到的响应内容用于调试 */
      char resp_debug_msg[ESP_RX_BUFFER_SIZE + 64];
      int resp_len = strlen(local_buffer);
      if(resp_len > 100) {
        snprintf(resp_debug_msg, sizeof(resp_debug_msg), "  [Response #%d] %.100s...\r\n",
                 response_count, local_buffer);
      } else {
        snprintf(resp_debug_msg, sizeof(resp_debug_msg), "  [Response #%d] %s\r\n",
                 response_count, local_buffer);
      }
      DEBUG_SendString(resp_debug_msg);

      /* 检查是否收到真正的ERROR响应 */
      /* 注意：命令回显可能包含"AT+MQTTPUB"，这不是ERROR */
      if(strstr(local_buffer, "ERROR") != NULL)
      {
        /* 排除命令回显的情况 - 回显通常以"AT+"开头 */
        if(strstr(local_buffer, "AT+") == NULL)
        {
          /* 这不是回显，是真正的ERROR */
          if(strstr(local_buffer, "OK") == NULL && strstr(local_buffer, "SEND OK") == NULL)
          {
            got_error = 1;
            DEBUG_SendString("[ERROR] MQTT publish failed - received ERROR\r\n");
            DEBUG_SendString("=== MQTT Publish Failed ===\r\n\r\n");
            return ESP_ERROR;
          }
        }
        /* 如果是命令回显+ERROR的情况，忽略这个ERROR判断 */
      }

      /* 检查是否收到OK */
      if(strstr(local_buffer, "OK") != NULL)
      {
        got_ok = 1;
      }

      /* 检查是否收到SEND OK */
      if(strstr(local_buffer, "SEND OK") != NULL)
      {
        got_send_ok = 1;
      }
    }
    else
    {
      /* 没有收到响应，打印调试信息（每2秒打印一次） */
      uint32_t elapsed = HAL_GetTick() - start_time;
      if(elapsed > 0 && elapsed % 2000 < 100)
      {
        char diag_msg[128];
        snprintf(diag_msg, sizeof(diag_msg),
                 "[WAITING] Still waiting for response... (%lu seconds elapsed)\r\n",
                 (unsigned long)(elapsed / 1000));
        DEBUG_SendString(diag_msg);
      }

      /* 如果已收到成功标志，等待一小段时间后退出 */
      if(got_ok || got_send_ok)
      {
        /* 等待额外300ms以确保没有更多响应 */
        uint32_t extra_wait = HAL_GetTick();
        while(HAL_GetTick() - extra_wait < 300)
        {
          if(esp_response_ready)
          {
            /* 保存响应到本地缓冲区 */
            char extra_buffer[ESP_RX_BUFFER_SIZE];
            strncpy(extra_buffer, (char*)esp_rx_buffer, ESP_RX_BUFFER_SIZE - 1);
            extra_buffer[ESP_RX_BUFFER_SIZE - 1] = '\0';

            /* 立即重置 */
            esp_response_ready = 0;
            esp_rx_index = 0;

            /* 还有响应，记录但不影响成功判断 */
            response_count++;
            /* 限制显示长度以避免缓冲区溢出 */
            int display_len = strlen(extra_buffer);
            if(display_len > 100) {
              snprintf(debug_msg, sizeof(debug_msg), "  [Extra Response #%d] %.100s...\r\n",
                       response_count, extra_buffer);
            } else {
              /* 使用 %.*s 限制最大输出长度为 200 字符 */
              snprintf(debug_msg, sizeof(debug_msg), "  [Extra Response #%d] %.*s\r\n",
                       response_count, display_len > 200 ? 200 : display_len, extra_buffer);
            }
            DEBUG_SendString(debug_msg);

            /* 在额外等待期间也检查ERROR */
            if(strstr(extra_buffer, "ERROR") != NULL &&
               strstr(extra_buffer, "OK") == NULL &&
               strstr(extra_buffer, "SEND OK") == NULL)
            {
              got_error = 1;
            }
          }
          HAL_Delay(10);
        }

        /* 如果在额外等待期间收到了ERROR，失败 */
        if(got_error)
        {
          DEBUG_SendString("[ERROR] MQTT publish failed - received ERROR after OK\r\n");
          DEBUG_SendString("=== MQTT Publish Failed ===\r\n\r\n");
          return ESP_ERROR;
        }

        DEBUG_SendString("[OK] Message published successfully\r\n");
        DEBUG_SendString("=== MQTT Publish Complete ===\r\n\r\n");
        return ESP_OK;
      }
    }

    ESP_DELAY(100);
  }
  
  /* 超时处理 - 检查是否有成功标志 */
  if(got_ok || got_send_ok)
  {
    DEBUG_SendString("[OK] Publish successful (late response)\r\n");
    DEBUG_SendString("=== MQTT Publish Complete ===\r\n\r\n");
    return ESP_OK;
  }
  else
  {
    char timeout_msg[100];
    snprintf(timeout_msg, sizeof(timeout_msg), 
             "[ERROR] Publish timeout - Received %d responses, no OK\r\n", response_count);
    DEBUG_SendString(timeout_msg);
    
    /* 发布失败后，检查ESP模块是否还活着 */
    DEBUG_SendString("[INFO] Checking if ESP module is still responsive...\r\n");
    
    /* 清空缓冲区并发送AT测试命令 */
    esp_response_ready = 0;
    esp_rx_index = 0;
    memset(esp_rx_buffer, 0, ESP_RX_BUFFER_SIZE);
    ESP_DELAY(100);
    
    ESP_SendATCommand("AT\r\n", 1000);
    
    uint32_t test_start = HAL_GetTick();
    uint8_t esp_alive = 0;
    
    while(HAL_GetTick() - test_start < 2000)
    {
      if(esp_response_ready)
      {
        if(strstr((char*)esp_rx_buffer, "OK") != NULL)
        {
          esp_alive = 1;
          DEBUG_SendString("[OK] ESP module is still responsive\r\n");
          break;
        }
        esp_response_ready = 0;
      }
      ESP_DELAY(10);
    }
    
    if(!esp_alive)
    {
      DEBUG_SendString("[CRITICAL] ESP module is not responding!\r\n");
      /* 尝试恢复ESP模块 */
      if(ESP_DetectAndRecover() == ESP_OK)
      {
        DEBUG_SendString("[RECOVERED] ESP module recovered, you may need to reconnect\r\n");
      }
      else
      {
        DEBUG_SendString("[CRITICAL] ESP recovery failed, power cycle recommended\r\n");
      }
    }
    
    DEBUG_SendString("=== MQTT Publish Failed ===\r\n\r\n");
    return ESP_ERROR;
  }
}

/**
  * @brief 检查ESP模块是否健康（能够响应AT命令）
  * @retval ESP_OK: 健康, ESP_ERROR: 不健康
  */
uint8_t ESP_CheckHealth(void)
{
  /* 清空接收缓冲区 */
  esp_response_ready = 0;
  memset(esp_rx_buffer, 0, sizeof(esp_rx_buffer));
  esp_rx_index = 0;

  /* 发送AT指令测试 */
  ESP_SendATCommand("AT\r\n", 1000);

  /* 等待响应 - 最多等待2秒 */
  uint32_t start_time = HAL_GetTick();
  while(HAL_GetTick() - start_time < 2000)
  {
    if(esp_response_ready)
    {
      if(strstr((char*)esp_rx_buffer, "OK") != NULL)
      {
        esp_response_ready = 0;
        return ESP_OK;
      }
      esp_response_ready = 0;
    }
    ESP_DELAY(50);
  }

  return ESP_ERROR;
}

/**
  * @brief WiFi和MQTT连接封装函数
  * @details 整合WiFi连接和MQTT配置、连接、订阅、发布的完整流程
  */
uint8_t ESP_ConnectWiFiAndMQTT(const char *wifi_ssid, const char *wifi_password,
                                const char *mqtt_client_id, const char *mqtt_username, const char *mqtt_password,
                                const char *mqtt_server, uint16_t mqtt_port, uint8_t mqtt_ssl,
                                const char *mqtt_subscribe_topic,
                                const char *mqtt_publish_topic, const char *mqtt_publish_message)
{
  /* 1. 检查WiFi自动连接状态 */
  uint8_t wifi_connected = 0;
  
  if(ESP_CheckAutoConnect() == ESP_OK)
  {
    /* WiFi已连接，获取IP地址 */
    ESP_Status_t* status = ESP_GetStatus();
    if(strlen(status->ip_address) > 0)
    {
      USART2_SendString("WiFi connected. IP: ");
      USART2_SendString(status->ip_address);
      USART2_SendString("\r\n");
      wifi_connected = 1;
    }
    else
    {
      /* 自动连接成功但没有IP地址，手动查询 */
      USART2_SendString("WiFi connected but no IP found, querying...\r\n");
      if(ESP_QueryIP() == ESP_OK)
      {
        ESP_Status_t* status = ESP_GetStatus();
        USART2_SendString("WiFi connected. IP: ");
        USART2_SendString(status->ip_address);
        USART2_SendString("\r\n");
        wifi_connected = 1;
      }
      else
      {
        USART2_SendString("Could not retrieve IP address\r\n");
        wifi_connected = 0;
      }
    }
  }
  
  /* 2. 如果WiFi未连接，尝试连接 */
  if(!wifi_connected)
  {
    if(ESP_ConnectWiFi(wifi_ssid, wifi_password) == ESP_OK)
    {
      /* WiFi连接成功，获取IP地址 */
      ESP_Status_t* status = ESP_GetStatus();
      if(strlen(status->ip_address) > 0)
      {
        USART2_SendString("WiFi connected. IP: ");
        USART2_SendString(status->ip_address);
        USART2_SendString("\r\n");
        wifi_connected = 1;
      }
      else
      {
        /* 连接成功但没有IP地址，手动查询 */
        USART2_SendString("WiFi connected but no IP found, querying...\r\n");
        if(ESP_QueryIP() == ESP_OK)
        {
          ESP_Status_t* status = ESP_GetStatus();
          USART2_SendString("WiFi connected. IP: ");
          USART2_SendString(status->ip_address);
          USART2_SendString("\r\n");
          wifi_connected = 1;
        }
        else
        {
          USART2_SendString("Could not retrieve IP address\r\n");
          wifi_connected = 0;
        }
      }
    }
    else
    {
      USART2_SendString("WiFi connection failed\r\n");
      return ESP_ERROR;
    }
  }
  
  /* 3. WiFi连接成功后，配置MQTT */
  if(!wifi_connected)
  {
    return ESP_ERROR;
  }
  
  USART2_SendString("Configuring MQTT...\r\n");
  if(ESP_ConfigureMQTT(mqtt_client_id, mqtt_username, mqtt_password) != ESP_OK)
  {
    USART2_SendString("MQTT configuration failed\r\n");
    return ESP_ERROR;
  }
  
  USART2_SendString("MQTT configured successfully\r\n");
  
  /* 4. 连接到MQTT服务器 */
  USART2_SendString("Connecting to MQTT server...\r\n");
  if(ESP_ConnectMQTT(mqtt_server, mqtt_port, mqtt_ssl) != ESP_OK)
  {
    USART2_SendString("MQTT connection failed\r\n");
    return ESP_ERROR;
  }
  
  USART2_SendString("MQTT connection successful!\r\n");
  
  /* 5. 等待MQTT连接完全建立（重要！） */
  USART2_SendString("Waiting for MQTT connection to stabilize...\r\n");
  HAL_Delay(2000);  /* 等待2秒，让MQTT连接完全建立 */
  
  /* 6. 订阅主题（如果提供） */
  if(mqtt_subscribe_topic != NULL && strlen(mqtt_subscribe_topic) > 0)
  {
    USART2_SendString("Subscribing to topic: ");
    USART2_SendString(mqtt_subscribe_topic);
    USART2_SendString("\r\n");
    if(ESP_SubscribeMQTT(mqtt_subscribe_topic) != ESP_OK)
    {
      USART2_SendString("MQTT subscription failed\r\n");
      return ESP_ERROR;
    }
    USART2_SendString("MQTT subscription successful!\r\n");
  }
  
  /* 7. 发布消息（如果提供） */
  if(mqtt_publish_topic != NULL && mqtt_publish_message != NULL &&
     strlen(mqtt_publish_topic) > 0 && strlen(mqtt_publish_message) > 0)
  {
    USART2_SendString("Publishing message to topic: ");
    USART2_SendString(mqtt_publish_topic);
    USART2_SendString("\r\n");
    if(ESP_PublishMQTT(mqtt_publish_topic, mqtt_publish_message) != ESP_OK)
    {
      USART2_SendString("MQTT message publish failed\r\n");
      return ESP_ERROR;
    }
    USART2_SendString("MQTT message published successfully!\r\n");
  }
  
  return ESP_OK;
}

/* USER CODE END PF */

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
